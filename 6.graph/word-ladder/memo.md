## step1
- 今探索している単語の各文字を変え、その単語が `wordList` に存在したら探索。
  - これを `beginWord` から行っていく。

- 重要なのは、例えば `hot`→`hit`→`nit` と `hot`→`not`→`nit` は区別しなくていいこと。
  - つまり、 `hit` と `not` どちらの探索で `nit` を探索候補にし、単語リストから削除したとしても、全体の結果に影響しない。
  - ただしBFSでないとだめ。
    - DFSの場合、 `nit` から削除してしまう可能性があるから。

- 以下の処理がEBCDICでは通らない。
  ```cpp
  for (char next_char = 'a'; next_char <= 'z'; ++next_char)
  ```
  - EBCDICの場合、26文字ハードコーディングするか、0~2^8の中で `std::islower` が真のものを英小文字とする。

## step2
- 他のコードを読む。

- 「変形する最小手順の探索(今回の問題)」と「次に探索できる文字の探索」は分けれる。
  - つまり、二重ループをループ二つに分けれる。
  - 参考：https://github.com/colorbox/leetcode/pull/34/

## step3
- 補完なしで5分半ほどで実装。
