## step1
- 時間計算量O(N), 空間計算量O(N)
- 前から見て、openの括弧のときstackにpush、closeの括弧のときstackにpop。探索後にstackが空なら全て対応している。
  - ただし、探索中に空のstackをpopする場合はcloseの括弧が過剰に存在する（=対応してない）のでfalse。
  - 括弧のマッチングでカウントする方法もあるが、今回は「括弧が出現する順番」を保持する必要があるので使えない。
- openの判定は`(`,`{`,`[`で3回する必要があるため、関数化して `isValid`（=全ての括弧が対応しているかの判定）と意味を分ける。
  - 関数に分けないと、 `bool isOpenBracket;`のように判定するためのフラグを定義する必要がある。これは読み手のワーキングメモリを圧迫すると判断。
  - また、`(`,`)`,`{`,`}`,`[`,`]`を切り分けた `isOpen`でしか使わないため。6つの括弧の定義と `isOpen`をprivateに格納する。
- `open_brackets`は `seen_open_brackets`と迷ったが、探索したものを入れてるのだから `seen`は自明と考え棄却。

## step2
- 調べてプッシュダウンオートマトンという単語を初めて知る。
  - 概念はstep1の解法と同じと認識
- stackのemplaceとpushの違い
  - `push`：既に構築済みのオブジェクト（またはコンテナが保持する要素型に変換可能なオブジェクト）を引数に取り、それをスタックにコピーまたはムーブして追加
  - `emplace`：要素型を構築するための引数を受け取り、その場で（in-place）コンストラクタを呼び出して新たな要素を直接生成
    - つまり、中間的な一時オブジェクトを生成せずに、スタック内部で要素が構築
- 使い分けとしては、「スタックへのコピーがオーバーヘッドになるオブジェクト」ほどemplaceを使った方が良いと解釈。
  - pushを使うケースは大方「引数のオブジェクトの寿命は短いが、スタックの寿命は長い（=引数オブジェクト解放後にスタックを参照する可能性がある）場合」だろう。

- 他の人のコードを見る。
  - 以下はそれを読んだ上での推敲

- 閉じる括弧の処理は以下が規則性あって見やすそう。
```cpp
} else {
  if (open_brackets.empty()) {
    return false;
  }
  if (open_to_close[open_brackets.top()] != bracket) {
    return false;
  }
  open_brackets.pop();
}
```
- しかし、以下二つの理由からやめる。
  1. 二つ目のif文が否定になっているのが認知負荷を高めていそう。
    - できるだけ素直な条件を入れたい。
  2. `open_brackets.top()`をそのまま入れているのが説明不足感がある。
    - つまり`open_brackets.top()`が「対応する開く括弧である」と変数名で説明したい。

- 開く括弧をガード条件にした方が、ネストが浅くなりそう。
```cpp
for (char bracket : s) {
  // 開く場合
  if (isOpen(bracket)) {
    open_brackets.push(bracket);
    continue;
  } 
  // 閉じる場合
  ...
}
```
- しかし、elseにすることで「ifは開く括弧、elseは開く括弧ではない（閉じる括弧）」と直感的に分かる
  - これは同じ粒度の処理である「開く括弧の処理」と「閉じる括弧の処理」が、同じタブの深さにあるからと考える。

## step3
- 3分半ほどで実装。同じ粒度で全体像を作るようにコーディングしていくと、カーソルの移動がオーバーヘッドになる。

## stepEx
- レビューで受けた点を修正して組む。
