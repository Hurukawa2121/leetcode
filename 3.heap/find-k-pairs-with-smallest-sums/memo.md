# step1
- 配列1の各要素と配列2の最小値 (`nums2[0]`) のペアをヒープに入れる。
- その後、候補になりうるペアをヒープに入れながら`K`回探索。
  - 高々7*10^5ほど。

- `index1`は引数`nums1`に合わせたがマジックナンバーは使いたくない。

- 変数名の長さを意識。
  - 文法の厳密さを少し犠牲に短くした。

- 差し過ぎだったかもしれない点。
  - 比較関数を作った点。
  - `std::pair<int, int>`を`typedef`で短い型名にした点。
- これらをしなくてもそこまで長くはなかったが、読みやすくなったと感じる。

- 比較は、`bool operator<()`にすると`nums1`と`nums2`を渡す必要があるので、ラムダ関数にする。
  - 意味的には`struct IndexPair`に比較関数があった方が良い。

# step2
- 探索ループ内の以下の処理は、
```cpp
auto [index1, index2] = smallest_pairs.top();
```
- 以下の方が役割が明確になるため変える。(長くなるが)
```cpp
auto [minimum_index1, minimum_index2] = minimum_indexes_heap.top();
```

- 他のコードを読む。

- いくつか亜種のアルゴリズムがあった。

- `minimum`を`min`にしていた。
  - よく見るのでスコープが狭ければ良いと思う。
  - 今回は変数によっては10行あるので`minimum`にする。
    - ここの感覚にズレがあればレビューをいただきたい。

# step3
- 5分ほどで実装
  - 保管やコピペがなければ10分ほどだろう
