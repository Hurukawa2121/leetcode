## step1
- 前から見て一つずつノードを足し、足すごとに下一桁の新しいノードを作って繋げ、下一桁以外は繰り上げれば良い。
  - 全加算器をイメージして書いた。

- 懸念点は、以下の似た処理を関数化しなかったこと。
```cpp
if (l1) sum += l1->val, l1 = l1->next;
if (l2) sum += l2->val, l2 = l2->next;
```
- 関数化をやめた理由は二つある。
  - `l1 = l1->next`などを関数で行う必要がある。出力引数は認知不可が高い。
  - 参照渡しするので、関数内がダブルポインタになる。認知負荷が高い。

- 以下の条件の順番は、carryを定義した後なので、carryがあった方が良いと考えこうした。
```cpp
int carry = 0;
while (carry > 0 || l1 || l2) {
```
- ただ、感覚的に繰り上げは最後に足されるため、その順に条件を書く選択肢も考えた。

- 時間計算量 O(N)、空間計算量 O(1)
  - 用途は思いつかないが、例えば電卓としての用途なら、10^9はゆうに越すので、O(N)だと遅く感じるだろう。この場合はリスト以外にすべき。

## step2
- 他の人のコードを読む。気になった処理は、l1,l2の各桁を格納する変数を定義するところ。
- 確かに、sumを不可変にすることができる。しかし、スコープが狭いためl1,l2の桁を足しているとすぐ分かる気もする。
  - ここあたりの「どれだけ媒介変数を定義し、命名を通してロジックを説明するか」の勘所がまだ掴めていない。

## step3
- 1分半ほどでクリア。上から順に書くのではなく、全体の流れを作ってから詳細を書いていく書き方に慣れてきて嬉しい。
